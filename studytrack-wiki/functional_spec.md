## F-01 소셜 로그인

### 프로젝트 나눔
- Core 기능 (필수/초기 기능)
    - 로그인
    - 분야/노트 관리
    - 문제 관리
    - 암기 세션
    - 캘린더 관리

- Infra & 공통 요소
    - 상태 관리 구조 설정 (Recoil/Zustand)
    - Editor 구성 (tiptap 세팅)
    - LLM 연동 구조 설계 (주관식/단답형 채점)
    - 백엔드 API 명세 작성
    - Swagger 적용
    - CI/CD (Lint + Push 제한)

- 추후 고려 Task (F-기능의 "추후 고려" 반영)
    - 실시간 저장
    - 반복 학습 일정
    - AI 리마인더


### 개요  
- Google, Naver, Kakao 소셜 로그인 지원  
- 자체 로그인 없음  
- OAuth 2.0 프로토콜 기반 인증  
- 토큰 받아서 백엔드로 전달 → JWT 발급 후 클라이언트 저장  

### 주요 흐름

1. 사용자가 로그인 화면에서 원하는 소셜 로그인 버튼 클릭  
2. OAuth 인증 팝업/리다이렉트 진행 (각 소셜별 인증)  
3. 인증 완료 후, OAuth 액세스 토큰 클라이언트 획득  
4. 액세스 토큰을 백엔드 `/auth/oauth-login` API에 전달  
5. 백엔드는 토큰 검증 → 사용자 정보 조회 및 신규 사용자 DB 저장  
6. JWT 토큰 발급 후 클라이언트에 전달  
7. 클라이언트는 JWT 토큰 저장 (LocalStorage 혹은 Secure Cookie)  
8. 로그인 성공 화면(메인 페이지)으로 이동  

### 예외 처리

- OAuth 인증 실패 또는 취소 시 → 로그인 실패 알림 표시  
- 백엔드 토큰 검증 실패 → 재로그인 유도  
- 네트워크 오류 시 → 적절한 오류 메시지 및 재시도 안내  

### API 명세 (요약)

| Method | Endpoint           | Request Body                  | Response Body                   |
|--------|--------------------|------------------------------|--------------------------------|
| POST   | /auth/oauth-login   | { provider: "google", token: "xxx" } | { jwt: "jwt_token", user: { id, name, email, profileImage } } |

### UI 구성 요소

- 로그인 페이지  
  - 소셜 로그인 버튼 3개 (Google, Naver, Kakao)  
  - 로그인 상태 알림 및 에러 메시지 영역  

---

### 추가 고려 사항

- JWT 저장 위치에 따른 보안 정책 수립 (XSS, CSRF 방지)  
- 토큰 갱신(Refresh Token) 정책 및 만료 처리  
- 로그아웃 시 토큰 삭제 및 세션 종료  

## F-02 학습 분야 생성 및 관리

### 개요  
- 사용자가 자유롭게 학습 분야(주제)를 생성하고 관리  
- 각 분야는 노트 및 문제와 연결됨 (1:N 관계)  
- 분야 설정은 사용자 개별 단위로 관리됨  

### 주요 흐름

1. 사용자가 "분야 추가" 버튼 클릭  
2. 입력창에서 분야 이름 작성 후 저장  
3. 등록된 분야는 리스트 형태로 화면에 표시됨  
4. 분야 클릭 시 해당 분야에 연결된 노트 및 문제 탐색  
5. 분야 수정, 삭제 가능 (삭제 시 하위 자료도 함께 제거 여부 선택)

### 예외 처리

- **중복된 분야명**: `"이미 존재하는 이름입니다"` 경고  
- **삭제 시**: “이 분야를 삭제하면 모든 하위 자료도 삭제됩니다. 계속할까요?” 확인 팝업

### API 명세 (요약)

| Method | Endpoint         | Request Body                  | Response Body                  |
|--------|------------------|-------------------------------|--------------------------------|
| POST   | /subjects         | { name: "자료구조" }            | { id: "abc123", name: "자료구조" } |
| GET    | /subjects         | -                             | [{ id, name }]                 |
| PUT    | /subjects/{id}    | { name: "새이름" }             | { id, name }                   |
| DELETE | /subjects/{id}    | -                             | { success: true }              |

### UI 구성 요소

- 분야 리스트 (사이드바 또는 카드형 목록)  
- “분야 추가” 버튼 및 입력 모달  
- 수정/삭제 액션 (아이콘 또는 드롭다운)  
- 삭제 확인 팝업  
- **분야 검색창**: 실시간 입력 시 리스트 필터링  

### 데이터 구조 예시

```json
{
  "id": "abc123",
  "name": "자료구조",
  "userId": "user123"
}

## F-03 학습 노트 에디터

### 개요  
- 사용자가 선택한 학습 분야 안에 자유롭게 노트를 작성할 수 있는 기능  
- 마크다운 스타일 기반의 에디터를 제공하며, 저장/편집 기능 포함  
- 추후 실시간 저장, 블록 단위 관리, 내보내기 등 고급 기능으로 확장 가능  

---

### 주요 흐름

1. 사용자가 특정 `학습 분야`를 선택  
2. "노트 추가" 버튼 클릭 → 에디터 화면 진입  
3. 에디터에서 텍스트, 제목, 코드 블럭, 리스트 등 입력  
4. "저장" 클릭 → 백엔드에 저장  
5. 노트는 해당 분야 내에서 리스트로 정렬됨  
6. 노트 클릭 시 편집 화면 재진입 (수정 가능)  
7. 추후: 실시간 자동 저장 기능 확장 예정  

---

### 에디터 라이브러리  
- 사용 라이브러리: [TipTap](https://tiptap.dev/)  
  - ProseMirror 기반의 블록형 확장형 에디터  
  - 블록 단위 처리 및 마크다운과 유사한 UX 제공  
  - 이미지 업로드, 테이블 등은 커스텀 확장으로 적용 가능  

---

### 지원 기능 (초기 버전 기준)

- 일반 텍스트 입력
- 제목 (`Heading 1`, `Heading 2`)
- 리스트
  - 순서 있는 리스트 (`1. 항목`)
  - 순서 없는 리스트 (`- 항목`)
- 체크리스트 (`[ ]`, `[x]`)
- 인라인 스타일링
  - **Bold** (`**굵게**`)
  - *Italic* (`*기울임*`)
  - ~~Strikethrough~~ (`~~취소선~~`)
  - `Inline Code` (백틱)
- 코드 블럭 (언어 선택 가능)
- 구분선 (`---`)
- 링크 삽입
- 마크다운 단축키 입력 지원 (`#`, `-`, `>`, ``` 등)

---

### 미지원 기능 (초기 제외)

- 이미지 업로드 (초기에는 URL 삽입만 고려)
- 표(Table)
- 파일 첨부
- 블록 정렬 (드래그 등은 향후 고려)
- 동시 편집 / 버전 관리

---

### 저장 방식

- 현재는 **명시적 수동 저장 버튼**을 통해 저장
- 추후 아래 방식으로 확장 고려:
  - 실시간 자동 저장 (`debounce + 변경 감지`)
  - 블록 단위 저장 (TipTap Node 기준)
  - LLM 기반 자동 요약, 태깅 연동

---

### API 명세 (요약)

| Method | Endpoint         | Request Body                     | Response Body                  |
|--------|------------------|----------------------------------|--------------------------------|
| POST   | /notes           | { title, content, subjectId }     | { id, title, content, subjectId } |
| GET    | /notes?subjectId | -                                | [{ id, title, createdAt }]     |
| PUT    | /notes/{id}      | { title, content }               | { id, title, content }         |
| DELETE | /notes/{id}      | -                                | { success: true }              |

---

### UI 요소 구성

- “노트 추가” 버튼
- 에디터 화면 (TipTap UI)
- 저장 버튼 / 나가기 버튼
- 수정 시 기존 내용 불러오기
- 제목 입력 필드
- 노트 리스트에서 최근 순 정렬

---

### 데이터 구조 예시

```json
{
  "id": "note123",
  "title": "이진 탐색 트리 정리",
  "content": "<p>이진 탐색 트리는 ...</p>",
  "subjectId": "subject123",
  "userId": "user456",
  "createdAt": "2025-07-24T12:00:00Z"
}

## F-04 문제 생성 및 풀이

### 개요
- 사용자가 특정 `학습 분야(Subject)`에 속한 문제를 생성하고 풀이할 수 있음
- 문제 유형은 객관식, 주관식, 단답형
- 문제는 `노트(Note)`와 연결되지 않으며, 동일한 `Subject` 하위에 독립적으로 존재
- 사용자는 문제를 풀기 전 세션 설정 팝업을 통해 타이머 및 문제 수를 선택할 수 있음
- 주관식 및 단답형 문제는 LLM 서버를 통해 자동 채점됨
- 결과는 저장되며, **맞은 문제도 사용자가 직접 북마크하여 복습 대상으로 관리 가능**

---

### 주요 흐름

1. 사용자가 특정 `학습 분야` 선택
2. "문제 추가" 클릭 → 문제 작성 화면 진입
3. 문제 유형 선택 후 내용 작성
   - 객관식: 질문 + 보기 + 정답
   - 주관식 / 단답형: 질문 + 정답 입력
   - 해설(Optional)
4. 저장 → 문제는 해당 Subject에 귀속
5. 사용자가 "문제 풀기" 클릭
   - 세션 팝업에서 제한 시간, 문제 수 설정
   - 설정 완료 후 문제 풀이 화면 진입
6. 문제는 한 페이지에 나열
   - 객관식: 보기 선택 → 자동 채점
   - 주관식/단답형: 사용자 입력 → 각 문제별로 LLM 서버 호출 → 유사도 평가 결과 표시
7. 문제 풀이 완료 후 "제출"
   - 결과 저장
   - 틀린 문제는 자동으로 오답노트에 저장
   - 맞은 문제도 사용자가 직접 북마크 가능

---

### 문제 유형별 필드

#### 객관식

| 필드 | 설명 |
|------|------|
| question | 문제 내용 |
| choices | 보기 목록 (2~5개) |
| correctIndex | 정답 보기 인덱스 |
| explanation | 해설 (Optional) |

#### 주관식 / 단답형

| 필드 | 설명 |
|------|------|
| question | 문제 내용 |
| correctAnswer | 기준 정답 |
| explanation | 해설 (Optional) |
| evaluation | LLM 평가 결과 (`correct`, `partial`, `wrong`) |

---

### 문제 세션 구성

- 세션 팝업에서 다음 설정:
  - 문제 수
  - 제한 시간 (분 단위)

- 문제 풀이 화면:
  - 모든 문제 나열
  - 객관식: 정답 선택 후 바로 평가
  - 주관식/단답형: 답안 입력 → **문제별로** LLM 서버에 유사도 판단 요청
  - 결과는 문제 하단에 바로 표시됨

---

### 오답/복습 관리

- 틀린 문제는 자동으로 오답노트에 저장
- 사용자는 맞은 문제도 북마크 가능 → 복습 대상으로 관리
- 오답노트 조회 시 필터 제공 예정
  - 오답만 보기
  - 북마크 문제 보기 등

---

### API 예시 (초안)

| Method | Endpoint | 설명 |
|--------|----------|------|
| POST | /subjects/:id/problems | 문제 생성 |
| GET | /subjects/:id/problems | 문제 목록 조회 |
| POST | /solve | 문제 풀이 제출 |
| POST | /judge | 주관식/단답형 LLM 채점 |
| GET | /users/:id/wrong-answers | 오답노트 조회 |

---

### 데이터 예시

#### 객관식

```json
{
  "id": "prob-123",
  "subjectId": "subj-456",
  "type": "objective",
  "question": "자료구조의 정의는?",
  "choices": ["데이터 저장", "알고리즘", "정렬", "트리"],
  "correctIndex": 0,
  "explanation": "자료구조는 데이터를 효율적으로 저장/관리하기 위한 방식입니다."
}

- 예시
```json
{
  "id": "prob-789",
  "subjectId": "subj-456",
  "type": "subjective",
  "question": "해시테이블의 충돌 해결 방법 중 하나를 설명하세요.",
  "correctAnswer": "체이닝",
  "evaluation": "partial",
  "explanation": "충돌 시 링크드 리스트로 연결하여 해결하는 방법이 체이닝입니다."
}

```

추후 고려 사항
- LLM 서버 연동 최적화
    - 문제별 병렬 요청 처리, 실패 시 재시도 로직
- 문제 랜덤 출제 / 셔플 기능
- 문제 복제 및 다시 풀기 기능
- PDF 출력 또는 인쇄용 문제지 자동 생성
- 풀이 기록 히스토리 확인 기능
- 자동 난이도 분류 (LLM 분석 기반)
- 오답노트 내 복습 세션 모드 제공
- 문제 유형별 통계 및 정답률 시각화

## F-05 오답노트 관리

### 개요
- 사용자가 문제 풀이 결과 중 **틀린 문제**를 자동으로 오답노트에 저장
- 사용자가 직접 북마크한 문제(맞은 문제 포함)도 오답노트에서 확인 가능
- 오답노트는 특정 학습 분야(Subject) 기준으로 분류됨
- 문제를 다시 풀어보는 **복습 기능** 포함

---

### 주요 흐름

1. 사용자가 문제 풀이 완료
2. 틀린 문제는 자동으로 오답노트에 저장됨
3. 맞은 문제도 사용자가 직접 **북마크**하면 오답노트에 포함됨
4. 사용자는 오답노트 메뉴 진입 시 다음 필터 제공:
   - 전체
   - 틀린 문제만
   - 북마크한 문제만
5. 각 문제 클릭 시:
   - 문제 상세 보기
   - 풀이 결과 확인 (정답 / 본인 답안 / LLM 평가)
   - 해설 보기
6. "다시 풀기" 버튼 클릭 시:
   - 해당 문제를 단독 또는 묶음으로 다시 풀이 가능
   - 결과는 히스토리로 누적 저장

---

### 데이터 구조 예시

```json
{
  "userId": "user-123",
  "subjectId": "subj-456",
  "wrongAnswers": [
    {
      "problemId": "prob-789",
      "type": "subjective",
      "question": "해시테이블의 충돌 해결 방법?",
      "userAnswer": "이중 해싱",
      "correctAnswer": "체이닝",
      "evaluation": "wrong",
      "bookmarked": true,
      "reviewed": false,
      "createdAt": "2025-07-24T12:34:56"
    }
  ]
}
```
### UI 흐름 요약
- 오답노트 진입
→ 필터 선택 (전체 / 틀린 문제 / 북마크)
→ 문제 리스트 클릭
→ 상세 페이지 (답변 비교 / 해설)
→ "다시 풀기"로 재도전

### API 예시 (초안)
| Method | Endpoint                                 | 설명           |
| ------ | ---------------------------------------- | ------------ |
| GET    | /users/\:id/wrong-answers                | 오답노트 조회      |
| PATCH  | /users/\:id/wrong-answers/\:pid/bookmark | 북마크 토글       |
| POST   | /review                                  | 다시 풀기 세션 시작  |
| GET    | /review/history                          | 문제별 풀이 이력 확인 |

### 추후 고려 사항
- 복습 세션 모드
    - 오답노트 내 문제만 모아서 자동 세션 구성
- 오답 회독 횟수 기록
    - 몇 번 다시 풀었는지 히스토리 저장
- 자동 태깅 (예: "반복 오답", "부분 정답")
- 정답률 통계 제공
    - 오답노트에서 각 분야별 정답률, 복습률 시각화
- 문제 자동 삭제 기준 설정
    - 일정 횟수 이상 맞은 문제는 자동 아카이빙
- 학습 리포트 생성 기능과 연동

## F-06 암기 세션 모드

### 개요

- 사용자가 작성한 **노트 내용을 기반으로** 암기 학습을 진행할 수 있는 모드
- 카드 형식의 UI로 요약 내용을 보여주고, 사용자는 스스로 암기 여부를 판단
- `암기 완료 / 미완료` 상태를 기록하여 반복 학습을 지원
- 사용자가 직접 **암기 세션 구성** 가능 (선택한 노트 또는 분야 기준)

---

### 주요 흐름

1. 사용자가 암기 세션 시작
   - 전체 노트, 특정 분야, 또는 특정 노트를 선택하여 세션 생성
2. 암기 세션은 다음과 같이 동작
   - 카드 형태로 노트 요약/내용 표시
   - 사용자가 "암기했음 / 기억 안 남" 선택
3. 세션 종료 시 결과 저장
   - 암기 성공/실패 목록 표시
   - 복습 필요 노트 자동 추천

---

### UI 및 인터랙션 흐름

- 카드 플립 UI  
  → 앞면: 제목 또는 키워드  
  → 뒷면: 요약, 설명  
  → 사용자는 스스로 암기 확인 후 체크  
  → `"암기했음"` 또는 `"기억 안 남"` 클릭  
  → 다음 카드로 이동

---

### 설정 옵션

- ✅ 분야 선택 (Subject)
- ✅ 노트 단위로 선택
- ✅ 무작위 카드 순서
- ✅ 반복 여부 설정 (`기억 안 남` 카드만 반복 가능)

---

### 데이터 구조 예시

```json
{
  "userId": "user-123",
  "sessionId": "mem-456",
  "subjectId": "subj-789",
  "cards": [
    {
      "noteId": "note-001",
      "title": "OSI 7계층",
      "content": "Application, Presentation, Session...",
      "status": "memorized" // or "not_memorized"
    }
  ],
  "createdAt": "2025-07-24T14:12:33",
  "completed": true
}
```

### API 예시 (초안)
| Method | Endpoint                         | 설명         |
| ------ | -------------------------------- | ---------- |
| POST   | /memorization-sessions           | 암기 세션 생성   |
| GET    | /memorization-sessions/\:id      | 암기 세션 불러오기 |
| PATCH  | /memorization-sessions/\:id/card | 카드 상태 업데이트 |
| GET    | /memorization-summary            | 암기 현황 요약   |

### 추후 고려 사항
- 세션 리포트 제공
    - 암기 성공률, 분야별 기억률 통계
    - 예: 네트워크 - 78% 암기, 운영체제 - 52%
- 카드 공유 기능
    - 노트 기반 암기 카드를 다른 사용자와 공유
- 시간 기반 반복 (Spaced Repetition)
    - 일정 주기마다 복습 세션 자동 생성 (예: 1일 후, 3일 후, 7일 후)
- 카드 북마크 기능
    - 특정 카드는 항상 복습하도록 설정 가능
- 학습 D-Day 캘린더와 연동
    - 암기 일정 캘린더에 자동 반영
- 암기 진척도 대시보드
| 항목           | 설명                                       |
| ------------ | ---------------------------------------- |
| 일간/주간 암기 성공률 | 날짜별로 얼마나 암기를 완료했는지 시각화 (예: 바 차트, 원형 그래프) |
| 분야별 암기 현황    | 각 분야의 총 암기 카드 수, 암기 성공률, 미암기 개수 등        |
| 히스토리 추적      | 동일 카드가 몇 회 반복됐는지, 암기 성공/실패 기록            |
| 암기 잔여 카드     | 아직 복습되지 않은 카드 수, 예정일 표시                  |
| 개인 평균 암기 성공률 | 사용자 평균 통계 (최근 7일/30일 기준)                 |

## f-07_calendar_learning_tracker.md

### F-07 학습 일정 캘린더 & 진행 관리

---

### 개요

- 사용자가 학습 목표일(D-Day 등)을 기준으로 일정 계획을 세우고  
  **날짜별 학습 내용을 기록 및 완료 여부를 체크**하는 기능
- 작성된 목표는 당일 기준으로 완료 여부를 표시하고, 이후에도 수정 가능
- 단순한 텍스트 기반 목표 체크 시스템

---

### 주요 흐름

1. 사용자는 캘린더에서 특정 날짜를 선택
2. 해당 날짜에 학습 목표를 입력 (텍스트 기반)
3. 학습 완료 시 사용자가 직접 **체크(✓) 또는 줄긋기** 형태로 완료 표시
4. **당일 내 미체크 항목은 자동으로 "미완료" 처리**
5. 사용자는 지나간 일정이라도 완료 여부 수정 가능

---

### 핵심 기능

| 기능 | 설명 |
|------|------|
| 날짜별 목표 입력 | 간단한 텍스트 입력 (예: "네트워크 요약 정리") |
| 완료 체크 | 수동 체크 or 줄긋기 스타일로 완료 표시 |
| 자동 미완료 처리 | 당일이 지나면 체크되지 않은 항목은 자동 미완료 처리 |
| 수정 가능 | 날짜가 지나도 사용자가 완료 상태 수정 가능 |

---

### 데이터 구조 예시

```json
{
  "userId": "user-123",
  "schedule": [
    {
      "date": "2025-08-01",
      "goal": "운영체제 요약 정리",
      "status": "completed" // or "incomplete"
    },
    {
      "date": "2025-08-02",
      "goal": "자료구조 문제 5문제 풀기",
      "status": "incomplete"
    }
  ]
}
```

### 추후 고려 사항
- 일정 반복 설정
    - 반복 학습 패턴 등록 가능 (예: 매주 화요일 “문제풀이” 자동 등록)
- 학습 목표 AI 리마인더
- 미완료 항목을 자동으로 다음날로 이월하거나, 하루 요약으로 알림 제공
- 달력 연동 분석 대시보드
    - 달성률 및 학습 이행 기록을 시각화하여 한눈에 확인